\documentclass[sigconf]{acmart}

% Remove ACM copyright/conference info for academic submission
\settopmatter{printacmref=false}
\renewcommand\footnotetextcopyrightpermission[1]{}
\pagestyle{plain}

% Packages
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{hyperref}

% Custom commands
\newcommand{\BigO}[1]{\mathcal{O}(#1)}

\begin{document}

\title{Analysis of Greedy and Divide-and-Conquer Algorithms: Real-World Applications}

\author{Pulkit Garg}
\email{pulkit.garg@ufl.edu}
\UFID{31125456}
\affiliation{%
  \institution{University of Florida}
  \city{Gainesville}
  \state{FL}
  \country{USA}
}

\author{Radhe Sharma}
\email{Radhe.Sharma@ufl.edu}
\UFID{31125456}
\affiliation{%
  \institution{University of Florida}
  \city{Gainesville}
  \state{FL}
  \country{USA}
}

\begin{abstract}
This paper presents the analysis and implementation of two fundamental algorithmic paradigms: greedy algorithms and divide-and-conquer algorithms. We identify real-world problems that can be optimally solved using each technique, provide formal problem abstractions, present algorithm designs with correctness proofs, analyze running times both theoretically and experimentally, and validate our analyses through empirical testing. Our results demonstrate the practical applicability and efficiency of these classical algorithmic techniques.
\end{abstract}

\keywords{Greedy Algorithms, Divide and Conquer, Algorithm Analysis, Computational Complexity}

\maketitle

\section{Introduction}

Algorithmic paradigms provide systematic approaches to solving computational problems efficiently. Among the most powerful techniques are \textit{greedy algorithms} and \textit{divide-and-conquer algorithms}, each offering unique strategies for tackling complex optimization and computational challenges.

Greedy algorithms make locally optimal choices at each step, hoping to find a global optimum. While this approach does not always guarantee optimal solutions, for certain problem classes—characterized by the greedy choice property and optimal substructure—greedy methods yield provably optimal results with excellent time complexity.

Divide-and-conquer algorithms recursively break problems into smaller subproblems, solve them independently, and combine their solutions. This paradigm often achieves significant improvements over brute-force approaches, transforming quadratic-time algorithms into linearithmic or even linear-time solutions.

In this paper, we analyze two real-world problems:

\begin{enumerate}
    \item \textbf{EV Charging Station Scheduling} (Greedy): Maximizing the number of electric vehicle charging sessions scheduled at a station with a single charger, subject to temporal constraints. This problem models the classical activity selection problem with real infrastructure data from 5,000 global charging stations.
    
    \item \textbf{Closest Pair of Points} (Divide-and-Conquer): Finding the pair of points with minimum Euclidean distance in a set of points in 2D space. This geometric problem has applications in collision detection, clustering, and spatial database indexing.
\end{enumerate}

For each problem, we provide: (1) real-world motivation, (2) formal problem abstraction, (3) algorithm design, (4) correctness proof, (5) complexity analysis, and (6) experimental validation using real data. Our implementations demonstrate both the theoretical elegance and practical utility of these algorithmic paradigms.

\section{Problem 1: EV Charging Station Scheduling (Greedy)}

\subsection{Real-World Problem}

Electric vehicle (EV) adoption is accelerating globally, creating unprecedented demand for charging infrastructure. Charging stations face a critical resource allocation challenge: with limited charging ports (often a single fast charger per station), operators must decide which charging requests to accept to maximize station utilization and serve the most customers.

Consider a DC fast-charging station receiving reservation requests throughout the day. Each request specifies a desired start time and charging duration. Requests often overlap, and the station can serve only one vehicle at a time. The goal is to select a maximum subset of non-overlapping requests to maximize the number of customers served.

This problem has significant economic and environmental implications:
\begin{itemize}
    \item \textbf{Revenue Optimization}: More sessions = more revenue
    \item \textbf{Customer Satisfaction}: Better scheduling reduces wait times
    \item \textbf{Grid Management}: Predictable scheduling aids load balancing
    \item \textbf{Infrastructure Planning}: Understanding demand patterns guides expansion
\end{itemize}

We obtained real infrastructure data from 5,000 EV charging stations globally, transformed their operational characteristics (charger types, capacity, usage patterns) into 5,449 realistic charging session requests, and applied our algorithm to this real-world dataset.

\subsection{Problem Abstraction}

This problem is an instance of the classical \textit{activity selection problem}.

\textbf{Input:} A set $S = \{s_1, s_2, \ldots, s_n\}$ of $n$ charging sessions, where each session $s_i$ is characterized by:
\begin{itemize}
    \item $start_i$: Start time (minutes since midnight)
    \item $finish_i$: Finish time (minutes since midnight)
\end{itemize}
We assume $finish_i > start_i$ for all sessions.

\textbf{Output:} A subset $A \subseteq S$ of mutually compatible sessions, where sessions $s_i$ and $s_j$ are \textit{compatible} if they do not overlap:
\[
finish_i \leq start_j \quad \text{or} \quad finish_j \leq start_i
\]

\textbf{Objective:} Maximize $|A|$ (the number of sessions scheduled).

\textbf{Optimal Substructure:} If session $s_k$ is the first session to finish in an optimal solution $A$, then $A \setminus \{s_k\}$ is an optimal solution to the subproblem consisting of sessions compatible with $s_k$.

\subsection{Algorithm Design}

Our greedy algorithm follows the \textit{earliest finish time first} strategy: always select the session that finishes earliest among remaining compatible sessions.

\begin{algorithm}
\caption{EV Charging Scheduler (Greedy)}
\label{alg:greedy}
\begin{algorithmic}[1]
\Require Set of sessions $S = \{s_1, \ldots, s_n\}$ with start and finish times
\Ensure Maximum subset $A$ of non-overlapping sessions
\State Sort $S$ by finish time: $finish_1 \leq finish_2 \leq \cdots \leq finish_n$ \quad $\BigO{n \log n}$
\State $A \gets \{s_1\}$ \quad (select first session to finish)
\State $last\_finish \gets finish_1$
\For{$i = 2$ to $n$} \quad $\BigO{n}$
    \If{$start_i \geq last\_finish$} \quad (session $s_i$ is compatible)
        \State $A \gets A \cup \{s_i\}$
        \State $last\_finish \gets finish_i$
    \EndIf
\EndFor
\Return $A$
\end{algorithmic}
\end{algorithm}

\textbf{Greedy Choice:} Always select the session that finishes earliest among remaining compatible sessions.

\textbf{Intuition:} By choosing the session that finishes first, we leave maximum "room" in the schedule for future sessions. This greedy choice never eliminates optimal solutions—any optimal solution can be modified to include the earliest-finishing session without decreasing the total number of sessions.

\subsection{Running Time Analysis}

\textbf{Time Complexity:} $\BigO{n \log n}$

\textbf{Detailed Analysis:}
\begin{enumerate}
    \item \textbf{Sorting (Line 1):} Sorting $n$ sessions by finish time using an efficient comparison-based sorting algorithm (e.g., merge sort, quicksort) takes $\BigO{n \log n}$ time.
    
    \item \textbf{Initialization (Lines 2-3):} Selecting the first session and initializing the last finish time takes $\BigO{1}$ time.
    
    \item \textbf{Iteration (Lines 4-9):} The for-loop iterates through the remaining $n-1$ sessions exactly once. For each session:
    \begin{itemize}
        \item Compatibility check (Line 5): $\BigO{1}$
        \item Adding to solution (Lines 6-7): $\BigO{1}$
    \end{itemize}
    Total loop time: $\BigO{n}$
\end{enumerate}

\textbf{Overall:} The dominant term is the sorting step, yielding $\BigO{n \log n}$ total time.

\textbf{Space Complexity:} $\BigO{n}$ for storing the solution set and the sorted array. If sorting in-place (e.g., heapsort), space can be reduced to $\BigO{k}$ where $k$ is the size of the solution.

\subsection{Proof of Correctness}

We prove that Algorithm~\ref{alg:greedy} produces an optimal solution using the \textit{exchange argument}.

\begin{proof}
Let $G = \{g_1, g_2, \ldots, g_k\}$ be the solution produced by the greedy algorithm, where sessions are ordered by finish time. Let $O = \{o_1, o_2, \ldots, o_m\}$ be an arbitrary optimal solution, also ordered by finish time.

We will show that $|G| = |O|$, proving optimality.

\textbf{Claim:} For all $i$, $finish(g_i) \leq finish(o_i)$.

\textbf{Proof of Claim (by induction):}

\textit{Base case ($i=1$):} The greedy algorithm selects $g_1$ as the session with the earliest finish time among all sessions. Therefore, $finish(g_1) \leq finish(o_1)$ holds by definition.

\textit{Inductive step:} Assume $finish(g_j) \leq finish(o_j)$ for all $j < i$. We show $finish(g_i) \leq finish(o_i)$.

After selecting $g_{i-1}$, the greedy algorithm chooses $g_i$ as the compatible session with the earliest finish time. Since $finish(g_{i-1}) \leq finish(o_{i-1})$ (by hypothesis), session $o_i$ is compatible with $g_{i-1}$ (because $o_i$ is compatible with $o_{i-1}$ and finishes later).

Therefore, $o_i$ is among the candidate sessions considered by the greedy algorithm at step $i$. Since the algorithm selects the session with earliest finish time, we have:
\[
finish(g_i) \leq finish(o_i)
\]

This completes the induction. \hfill $\square$ (Claim)

\textbf{Main Argument:}

The claim implies that the greedy solution "stays ahead" of any optimal solution—at every step, the greedy choice finishes no later than the corresponding choice in the optimal solution.

Now suppose for contradiction that $|G| < |O|$. Then $O$ has more sessions than $G$. Consider session $o_{k+1}$ (the $(k+1)$-th session in $O$). By the claim, $finish(g_k) \leq finish(o_k)$. Therefore:
\[
start(o_{k+1}) \geq finish(o_k) \geq finish(g_k)
\]

This means $o_{k+1}$ is compatible with $g_k$ and would have been selected by the greedy algorithm at step $k+1$. But the algorithm terminated after selecting $g_k$, meaning no compatible sessions remain. This is a contradiction.

Therefore, $|G| \geq |O|$. Since $O$ is optimal, we have $|G| = |O|$, proving that the greedy algorithm produces an optimal solution.
\end{proof}

\subsection{Domain-Specific Explanation}

From an EV charging station operator's perspective, the algorithm implements a simple and intuitive scheduling policy:

\textbf{Scheduling Rule:} When a charging session completes, immediately serve the next customer whose requested arrival time has passed, prioritizing those who can finish charging soonest.

\textbf{Rationale:} Quick-charging customers (e.g., DC fast charging for 20-30 minutes) "turn over" the charger faster, allowing more total customers to be served. This policy naturally emerges from our greedy strategy without explicitly distinguishing charger types—the algorithm automatically prioritizes shorter sessions that happen to be compatible.

\textbf{Practical Benefits:}
\begin{itemize}
    \item \textbf{Simple Implementation:} Operators can implement this with a priority queue sorted by estimated completion time
    \item \textbf{Real-Time Decisions:} No need to wait for all requests; decisions are made incrementally
    \item \textbf{Fair:} First-compatible, earliest-finish serves customers in a predictable manner
    \item \textbf{Provably Optimal:} Maximizes station throughput (number of customers served)
\end{itemize}

\subsection{Experimental Results}

We conducted comprehensive experiments to validate our theoretical analysis and demonstrate real-world applicability using data from 5,000 global EV charging stations transformed into 5,449 realistic charging sessions.

\textbf{Dataset:} Session durations reflect actual charger characteristics: DC Fast Chargers (15-45 min), AC Level 2 (1-4 hours), AC Level 1 (4-8 hours). Total energy delivered: 1,357,652 kWh over 7 days across 500 stations.

\textbf{Experiment 1: Alternative Greedy Strategy Comparison}

To demonstrate the superiority of the earliest-finish-time strategy, we implemented and compared five alternative greedy approaches:

\begin{enumerate}
    \item \textbf{FCFS (Greedy):} First-Come-First-Served approach that selects sessions by earliest start time while checking for conflicts (greedy version of classic FCFS)
    \item \textbf{Shortest Duration:} Select sessions by shortest charging time
    \item \textbf{Latest Start Time:} Select sessions by latest start time (backward greedy)
    \item \textbf{Fewest Conflicts:} Select sessions with minimum overlaps
    \item \textbf{Max Energy Density:} Select sessions by energy/duration ratio
\end{enumerate}

Figure~\ref{fig:greedy_strategy_comparison} shows comprehensive comparison across 20 random trials with n=200 sessions each. Key findings:

\begin{itemize}
    \item \textbf{Earliest Finish (Optimal):} 26.8 sessions average (100\% baseline)
    \item \textbf{FCFS (Greedy):} 13.9 sessions (52\% - worst performer)
    \item \textbf{Shortest Duration:} 25.3 sessions (94\% - good but suboptimal)
    \item \textbf{Latest Start:} 26.8 sessions (100\% - lucky on this dataset)
    \item \textbf{Fewest Conflicts:} 26.7 sessions (99.6\% - nearly optimal but O($n^3$))
    \item \textbf{Max Energy Density:} 25.5 sessions (95\% - domain heuristic)
\end{itemize}

This comparison validates our theoretical proof empirically: only the earliest-finish-time strategy consistently achieves optimal performance with theoretical guarantees. The FCFS (First-Come-First-Served) approach—commonly used in practice for its simplicity—performs worst at only 52\% of optimal, demonstrating that serving customers in arrival order can be highly suboptimal.

\begin{figure}[h]
\centering
\includegraphics[width=0.9\columnwidth]{figures/greedy_strategy_comparison.png}
\caption{Comprehensive comparison of six greedy strategies across multiple metrics. Box plots, performance analysis, and statistical summaries show earliest-finish-time strategy consistently achieves optimal results while alternatives are 5-50\% suboptimal.}
\label{fig:greedy_strategy_comparison}
\end{figure}

\textbf{Experiment 2: Runtime and Complexity Analysis}

To demonstrate that optimal doesn't mean slow, we analyzed the computational efficiency of all six strategies across varying input sizes (n=100 to 5,000). Figure~\ref{fig:greedy_runtime_comparison} presents comprehensive runtime analysis including:

\begin{itemize}
    \item \textbf{Runtime Scaling:} Log-log plots show growth rates matching theoretical complexity
    \item \textbf{Comparison Counts:} Number of operations performed by each strategy
    \item \textbf{Efficiency Metrics:} Runtime and comparisons relative to optimal
\end{itemize}

Key findings for n=5,000 sessions:
\begin{itemize}
    \item \textbf{Optimal (Earliest Finish):} 1.47 ms runtime, 4,999 comparisons - $\BigO{n \log n}$
    \item \textbf{FCFS (Greedy):} 1.42 ms - Fast but produces worst solutions (52\% optimal)
    \item \textbf{Shortest Duration:} 11.22 ms - 7.6$\times$ slower, still suboptimal
    \item \textbf{Fewest Conflicts:} 20,730 ms - 14,055$\times$ slower with $\BigO{n^3}$ complexity
\end{itemize}

\textbf{Critical Insight:} Our optimal strategy is not only provably correct but also computationally efficient. Despite guaranteeing optimality, it runs as fast as the simplest FCFS approach and dramatically faster than alternatives like Fewest Conflicts. This demonstrates that \textit{choosing the right greedy criterion yields both correctness and efficiency}.

\begin{figure}[h]
\centering
\includegraphics[width=0.9\columnwidth]{figures/greedy_runtime_comparison.png}
\caption{Runtime and complexity analysis of six greedy strategies. Log-log scaling plots, comparison counts, and efficiency metrics demonstrate that the optimal earliest-finish-time strategy is also computationally efficient ($\BigO{n \log n}$), while suboptimal alternatives like Fewest Conflicts suffer from $\BigO{n^3}$ complexity.}
\label{fig:greedy_runtime_comparison}
\end{figure}

\textbf{Summary:} Our experiments comprehensively validate the earliest-finish-time greedy strategy through both optimality comparison and efficiency analysis. We demonstrate significant practical improvement over alternatives (FCFS at only 52\% optimal), confirm theoretical $\BigO{n \log n}$ complexity with runtime measurements, and prove that the optimal solution is also computationally efficient—running as fast as simple approaches while guaranteeing correctness on real-world EV charging data.

\section{Problem 2: Divide and Conquer}

\subsection{Problem Description}

% TODO: Describe the real-world problem
% Example topics to consider:
% - Closest Pair of Points (computational geometry)
% - Integer Multiplication (cryptography)
% - Merge Sort variations (data processing)
% - Fast Fourier Transform (signal processing)
% - Binary Search variations (information retrieval)

[Describe your chosen real-world problem here]

\subsection{Problem Abstraction}

\textbf{Input:} [Define the input formally]

\textbf{Output:} [Define the desired output formally]

\subsection{Algorithm Design}

\begin{algorithm}
\caption{[Your Divide and Conquer Algorithm Name]}
\label{alg:dnc}
\begin{algorithmic}[1]
\Require [Input requirements]
\Ensure [Output specifications]
\If{[base case]}
    \State [handle base case]
\EndIf
\State [Divide step]
\State [Conquer step (recursive calls)]
\State [Combine step]
\Return [result]
\end{algorithmic}
\end{algorithm}

\subsection{Running Time Analysis}

\textbf{Recurrence Relation:} $T(n) = ?$

[Derive the recurrence relation and solve it using Master Theorem or recursion tree method]

\textbf{Time Complexity:} $\BigO{?}$

\subsection{Proof of Correctness}

\begin{proof}
[Prove correctness using induction on the size of the input]
\begin{enumerate}
    \item Base case: [Prove for smallest input]
    \item Inductive hypothesis: [Assume correct for smaller inputs]
    \item Inductive step: [Prove for general case]
\end{enumerate}
\end{proof}

\subsection{Domain-Specific Explanation}

[Explain the algorithm in the context of the original problem]

\subsection{Experimental Results}

\begin{figure}[h]
\centering
\includegraphics[width=0.8\columnwidth]{figures/dnc_runtime.png}
\caption{Running time analysis of the divide-and-conquer algorithm}
\label{fig:dnc_runtime}
\end{figure}

[Discuss experimental results]

\section{Conclusion}

This paper demonstrates the power and elegance of two fundamental algorithmic paradigms through real-world applications.

\textbf{Greedy Algorithm (EV Charging Scheduling):} Our analysis confirms that the earliest-finish-time greedy strategy optimally solves the activity selection problem. Key contributions include:
\begin{enumerate}
    \item \textbf{Formal correctness proof} via exchange argument
    \item \textbf{Real-world validation} using data from 5,000 global EV stations
    \item \textbf{2.6$\times$ improvement} over FCFS baseline
    \item \textbf{$\BigO{n \log n}$ runtime} experimentally verified (6.8ms for 16K sessions)
\end{enumerate}

The algorithm's simplicity and efficiency make it immediately deployable for EV infrastructure operators. Our transformation methodology—converting static station data to dynamic session data based on charger characteristics—demonstrates how domain knowledge enhances algorithmic research.

\textbf{Divide-and-Conquer Algorithm (Closest Pair):} [To be completed with D\&C results]

\textbf{Broader Impact:} This work illustrates how classical algorithm design techniques remain highly relevant for modern problems. The greedy paradigm's optimality, when applicable, provides both theoretical guarantees and practical performance. Our experimental methodology—using real data, comparing against baselines, and providing reproducible results—sets a standard for algorithm evaluation.

\textbf{Future Work:}
\begin{itemize}
    \item \textbf{Dynamic Scheduling:} Extend to handle online requests (sessions arriving in real-time)
    \item \textbf{Multi-Resource:} Generalize to stations with multiple chargers (interval partitioning)
    \item \textbf{Weighted Scheduling:} Consider revenue optimization (different pricing tiers)
    \item \textbf{Stochastic Model:} Account for uncertainty in charging durations
    \item \textbf{Deployment:} Pilot study at actual charging stations to measure real-world impact
\end{itemize}

This project demonstrates that fundamental algorithmic principles—greedy choice property, optimal substructure, divide-and-conquer—provide powerful tools for solving contemporary optimization challenges in sustainable transportation infrastructure.

\bibliographystyle{ACM-Reference-Format}
\bibliography{bibliography}

\appendix

\section{LLM Usage Documentation}

% TODO: Document all LLM usage with prompts and responses

\begin{table}[h]
\centering
\begin{tabular}{|p{2cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Tool} & \textbf{Prompt} & \textbf{Usage} \\
\hline
[Tool name] & [Exact prompt] & [How result was used] \\
\hline
\end{tabular}
\caption{LLM Usage Log}
\end{table}

\section{Source Code}

% Include your implementation code here or reference it
% You can use the listings package for code formatting

[Include key portions of your code here]

\end{document}
